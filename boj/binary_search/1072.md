
# 2. 백준 1072번 문제: 게임

백준 1072번 문제는 **게임의 승률**을 구하고, **목표 승률에 도달하기 위해 필요한 최소 추가 게임 수를 찾는 문제**야. 이 문제는 **이진 탐색**을 이용해서 특정 승률 이상을 달성하는 최소 게임 횟수를 빠르게 찾는 것이 핵심이야.

## 문제 설명

- **입력**: `x`와 `y`를 입력으로 받아. 여기서 `x`는 총 게임 수, `y`는 이긴 게임 수야.
- **출력**: 승률을 목표치 이상으로 올리기 위해 **최소 몇 번의 게임을 더 이겨야 하는지 출력**해.

## 접근 방법

1. **현재 승률 계산**: 
   - `z = (y * 100) / x`로 현재 승률을 계산한다.

2. **이진 탐색 설정**:
   - 목표 승률 이상을 달성하기 위한 최소 게임 횟수를 찾기 위해, 탐색 범위 `[0, 1,000,000,000]`에서 이진 탐색을 수행한다.

3. **이진 탐색 진행**:
   - 중앙값 `m`을 추가로 이긴 게임 횟수라고 가정하고, 새로운 승률 `z_n`을 계산한다.
   - `z_n > z`인 경우, `r = m - 1`로 탐색 범위를 줄이고 `result = m`으로 저장해 최소 게임 수를 갱신한다.
   - `z_n <= z`라면, `l = m + 1`로 탐색 범위를 오른쪽으로 이동한다.

4. **최소 횟수 출력**:
   - 이진 탐색을 완료한 후, 목표 승률 이상을 달성할 수 있으면 `result`에 최소 게임 횟수가 저장되어 있으므로 이를 출력하고, 그렇지 않으면 `-1`을 출력한다.

## 최종 코드 (C++)

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    cin.tie(NULL);
    ios::sync_with_stdio(false);

    long long x, y;
    cin >> x >> y;

    int z = (y * 100) / x, z_n;  // 초기 승률 계산
    long long l = 0, r = 1  000000000, n;
    long long result = -1;

    while (l <= r) {
        m = (r + l) / 2;
        z_n = (y + n) * 100 / (x + n)
        if (z < z_n) { 
            result = m;
            r = n - 1;
        } else {
            l = n + 1;
        }
    }

    cout << result;
    return 0;
}
```

## 풀이 설명
- 이 코드에서는 `z`와 `z_n` 비교를 통해 목표 승률 도달 여부를 확인하며, 이진 탐색을 사용해 효율적으로 최소 추가 게임 횟수를 찾는다.
- 최종적으로 `result`에 저장된 값이 최소 게임 횟수이며, 목표 승률이 불가능하면 `-1`이 출력된다.

---

