
# 코딩테스트에서의 시간 복잡도와 알고리즘 선택

코딩테스트에서는 **입력 크기**과 **시간 제한**에 맞는 **적절한 시간 복잡도**를 가진 알고리즘을 선택해야한다. 일반적으로 **1초에 약 1억 번의 연산**을 진행한다 가정한다.

---

## 1. 시간 복잡도 표기법 (Big-O)

### 주요 시간 복잡도와 예시

- **O(1) – 상수 시간**
  - 입력 크기와 상관없이 항상 같은 시간에 동작하는 알고리즘.
  - 배열 인덱스 접근, 특정 위치 조회.

- **O(log N) – 로그 시간**
  - 입력이 커져도 매번 절반씩 줄어들며 시간이 감소하는 알고리즘.
  - **이진 탐색** 등이 대표적.

- **O(N) – 선형 시간**
  - 입력 크기(n)에 비례하여 시간이 증가하는 알고리즘.
  - 배열 순회, 단순한 리스트 검색.

- **O(N log N) – 로그-선형 시간**
  - 정렬 알고리즘에서 주로 나타나는 시간 복잡도.
  - **병합 정렬(Merge Sort)**, **퀵 정렬(Quick Sort)**.

- **O(N^2) – 이차 시간**
  - 이중 반복문에서 발생하며, n이 증가할 때 성능이 급격히 떨어짐.
  - **버블 정렬**, **플로이드-와샬 알고리즘** 등.

- **O(2^N) – 지수 시간**
  - 완전탐색 문제에서 발생하는 시간 복잡도. 작은 n에서도 시간이 급격히 증가.
  - **피보나치 수열 재귀**, **백트래킹**.

- **O(N!) – 팩토리얼 시간**
  - 순열을 모두 탐색하거나, N-Queen 문제 같은 문제에서 나타남.
  - 모든 경우의 수를 전부 계산하는 알고리즘.

---

## 2. 입력 크기(n)에 따른 적합한 알고리즘 선택

| 입력 크기 (n)  | 적합한 시간 복잡도 | 알고리즘 예시 |
|----------------|---------------------|---------------|
| **n ≤ 10**     | O(N!), O(2^N)       | 백트래킹, 순열 탐색 |
| **n ≤ 20**     | O(2^N)              | 비트마스크, 완전탐색 |
| **n ≤ 100**    | O(N^2), O(N^3)      | 동적 계획법(DP), 플로이드-와샬 |
| **n ≤ 1,000**  | O(N^2), O(N log N)  | 이중 반복문, 정렬, 동적 계획법 |
| **n ≤ 100,000**| O(N log N), O(N)    | 이진 탐색, 정렬, 슬라이딩 윈도우 |
| **n ≤ 1,000,000**| O(N log N), O(N) | 세그먼트 트리, 해시맵 |
| **n ≤ 1,000,000,000**| O(log N), O(1)| 이진 탐색, 분할 정복 |

---

## 3. 시간 복잡도와 알고리즘 예시

### O(1) – 상수 시간
```cpp
int arr[1000];
int x = arr[5];  // O(1)
```

### O(log N) – 로그 시간
```cpp
// 이진 탐색 O(log N)
int binarySearch(int arr[], int target, int n) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

### O(N) – 선형 시간
```cpp
// 배열에서 최대값 찾기 O(N)
int findMax(int arr[], int n) {
    int maxVal = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > maxVal) maxVal = arr[i];
    }
    return maxVal;
}
```

### O(N log N) – 로그-선형 시간
```cpp
// 병합 정렬 O(N log N)
void mergeSort(int arr[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        mergeSort(arr, low, mid);
        mergeSort(arr, mid + 1, high);
        merge(arr, low, mid, high);
    }
}
```

### O(N^2) – 이차 시간
```cpp
// 버블 정렬 O(N^2)
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

### O(2^N) – 지수 시간
```cpp
// 재귀적 피보나치 O(2^N)
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

---

## 4. 코딩테스트에서 시간 복잡도 판단 순서

1. **입력 크기 분석**: 문제에서 주어진 입력 크기를 먼저 확인한다.
2. **시간 복잡도 예상**: 적합한 알고리즘의 시간 복잡도를 예측하고, 제한 시간 내에 해결 가능한지 판단한다.
3. **알고리즘 선택**: 입력 크기에 맞는 적절한 알고리즘을 선택하여 시간 초과를 피한다.

---

### 요약
- 시간 복잡도는 **입력 크기(n)**에 따라 달라지며, 코딩테스트에서 효율적인 알고리즘을 선택하는 것이 중요하다.
- 일반적으로 **1초에 약 1억 번의 연산**을 처리할 수 있다고 가정하고, 이를 기준으로 알고리즘을 선택한다.
- **n이 클수록 O(N log N) 이하의 알고리즘**을 사용하는 것이 유리하다.
